"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[429],{3665:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"docs/Benchmarking/drive-benchmarking","title":"Drive Benchmarking","description":"CatP2P provides comprehensive drive benchmarking functionality to assess the performance of storage devices. This is crucial for distributed applications that need to store and retrieve data efficiently.","source":"@site/docs/docs/Benchmarking/drive-benchmarking.md","sourceDirName":"docs/Benchmarking","slug":"/docs/Benchmarking/drive-benchmarking","permalink":"/catp2p/docs/docs/Benchmarking/drive-benchmarking","draft":false,"unlisted":false,"editUrl":"https://github.com/johnnyvillas/catp2p/tree/main/docs-site/docs/docs/Benchmarking/drive-benchmarking.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"CPU Benchmarking","permalink":"/catp2p/docs/docs/Benchmarking/cpu-benchmarking"},"next":{"title":"Memory Benchmarking","permalink":"/catp2p/docs/docs/Benchmarking/memory-benchmarking"}}');var s=r(4848),a=r(8453);const t={sidebar_position:2},c="Drive Benchmarking",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Simple Benchmark",id:"simple-benchmark",level:3},{value:"Benchmarking a Specific Drive",id:"benchmarking-a-specific-drive",level:3},{value:"Benchmarking All Drives",id:"benchmarking-all-drives",level:3},{value:"Getting Drive Information",id:"getting-drive-information",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Custom Benchmark Configuration",id:"custom-benchmark-configuration",level:3},{value:"Finding the Best Drive for Storage",id:"finding-the-best-drive-for-storage",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"API Reference",id:"api-reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"drive-benchmarking",children:"Drive Benchmarking"})}),"\n",(0,s.jsx)(n.p,{children:"CatP2P provides comprehensive drive benchmarking functionality to assess the performance of storage devices. This is crucial for distributed applications that need to store and retrieve data efficiently."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The drive benchmarking module allows you to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Benchmark individual drives or all available drives"}),"\n",(0,s.jsx)(n.li,{children:"Measure write speed, read speed, and random access performance"}),"\n",(0,s.jsx)(n.li,{children:"Get detailed information about available drives"}),"\n",(0,s.jsx)(n.li,{children:"Compare performance across different storage devices"}),"\n",(0,s.jsx)(n.li,{children:"Customize benchmark parameters"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.h3,{id:"simple-benchmark",children:"Simple Benchmark"}),"\n",(0,s.jsx)(n.p,{children:"To run a simple benchmark on the system's temporary directory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::drives;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Run a simple benchmark and get the overall score\n    let score = drives::run_drive_benchmark()?;\n    println!("Drive benchmark score: {:.2}", score);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"benchmarking-a-specific-drive",children:"Benchmarking a Specific Drive"}),"\n",(0,s.jsx)(n.p,{children:"To benchmark a specific drive with custom parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::drives::{DriveBenchmarkConfig, run_drive_benchmark_with_config};\nuse std::path::Path;\n\nfn main() -> Result<(), catp2p::error::Error> {\n    // Create a custom configuration\n    let config = DriveBenchmarkConfig {\n        file_size_mb: 100,           // Size of test file in MB\n        random_access_ops: 1000,     // Number of random access operations\n        include_random_access: true, // Include random access test\n    };\n    \n    // Benchmark a specific drive\n    let drive_path = Path::new("C:\\\\"); // Windows example\n    // let drive_path = Path::new("/"); // Unix example\n    \n    let result = run_drive_benchmark_with_config(drive_path, &config)?;\n    \n    println!("Benchmark results for {}:", drive_path.display());\n    println!("  Write Speed: {:.2} MB/s", result.write_speed);\n    println!("  Read Speed: {:.2} MB/s", result.read_speed);\n    println!("  Random Access: {:.2} ops/s", result.random_access_speed);\n    println!("  Overall Score: {:.2}", result.overall_score);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"benchmarking-all-drives",children:"Benchmarking All Drives"}),"\n",(0,s.jsx)(n.p,{children:"To benchmark all available drives:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::drives::run_all_drives_benchmark;\n\nfn main() -> Result<(), catp2p::error::Error> {\n    // Benchmark all available drives\n    let results = run_all_drives_benchmark()?;\n    \n    for (i, result) in results.iter().enumerate() {\n        println!("Drive {}: {}", i + 1, result.path.display());\n        println!("  Write Speed: {:.2} MB/s", result.write_speed);\n        println!("  Read Speed: {:.2} MB/s", result.read_speed);\n        println!("  Random Access: {:.2} ops/s", result.random_access_speed);\n        println!("  Overall Score: {:.2}", result.overall_score);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"getting-drive-information",children:"Getting Drive Information"}),"\n",(0,s.jsx)(n.p,{children:"To get information about all available drives without running benchmarks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::drives::get_drives_info;\n\nfn main() {\n    let drives_info = get_drives_info();\n    \n    for drive_info in drives_info {\n        println!("Drive: {} ({})", drive_info.name, drive_info.path.display());\n        println!("  File System: {}", drive_info.file_system);\n        println!("  Total Capacity: {:.2} GB", \n            drive_info.total_capacity as f64 / (1024.0 * 1024.0 * 1024.0));\n        println!("  Available Space: {:.2} GB", \n            drive_info.available_space as f64 / (1024.0 * 1024.0 * 1024.0));\n        println!("  Removable: {}", drive_info.is_removable);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,s.jsx)(n.h3,{id:"custom-benchmark-configuration",children:"Custom Benchmark Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"DriveBenchmarkConfig"})," struct allows you to customize the benchmark parameters:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let config = DriveBenchmarkConfig {\n    // Size of the test file in MB (larger files provide more accurate results but take longer)\n    file_size_mb: 500,\n    \n    // Number of random access operations to perform\n    random_access_ops: 5000,\n    \n    // Whether to include random access test (can be disabled for faster benchmarks)\n    include_random_access: true,\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"finding-the-best-drive-for-storage",children:"Finding the Best Drive for Storage"}),"\n",(0,s.jsx)(n.p,{children:"A common use case is to find the best drive for storing data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::drives::{get_drives_info, run_drive_benchmark_with_config, DriveBenchmarkConfig};\nuse std::path::Path;\n\nfn main() -> Result<(), catp2p::error::Error> {\n    // Get all drives with at least 10GB free space\n    let min_free_space = 10 * 1024 * 1024 * 1024; // 10GB in bytes\n    let suitable_drives: Vec<_> = get_drives_info()\n        .into_iter()\n        .filter(|drive| drive.available_space >= min_free_space)\n        .collect();\n    \n    if suitable_drives.is_empty() {\n        println!("No drives with sufficient free space found.");\n        return Ok(());\n    }\n    \n    // Create a benchmark configuration\n    let config = DriveBenchmarkConfig {\n        file_size_mb: 100,\n        random_access_ops: 1000,\n        include_random_access: true,\n    };\n    \n    // Benchmark each suitable drive\n    let mut best_drive = None;\n    let mut best_score = 0.0;\n    \n    for drive_info in suitable_drives {\n        match run_drive_benchmark_with_config(&drive_info.path, &config) {\n            Ok(result) => {\n                println!("Benchmarked {}: Score {:.2}", \n                    drive_info.path.display(), result.overall_score);\n                \n                if result.overall_score > best_score {\n                    best_score = result.overall_score;\n                    best_drive = Some((drive_info, result));\n                }\n            },\n            Err(e) => {\n                println!("Failed to benchmark {}: {}", drive_info.path.display(), e);\n            }\n        }\n    }\n    \n    // Report the best drive\n    if let Some((drive_info, result)) = best_drive {\n        println!("\\nBest drive for storage: {}", drive_info.path.display());\n        println!("  Overall Score: {:.2}", result.overall_score);\n        println!("  Write Speed: {:.2} MB/s", result.write_speed);\n        println!("  Read Speed: {:.2} MB/s", result.read_speed);\n        println!("  Available Space: {:.2} GB", \n            drive_info.available_space as f64 / (1024.0 * 1024.0 * 1024.0));\n    } else {\n        println!("No suitable drives could be benchmarked.");\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Benchmarking drives can be I/O intensive and may temporarily impact system performance"}),"\n",(0,s.jsx)(n.li,{children:"For the most accurate results, close other applications during benchmarking"}),"\n",(0,s.jsx)(n.li,{children:"System drives (like C: on Windows) may show lower performance if the OS is running from them"}),"\n",(0,s.jsx)(n.li,{children:"SSD performance can vary based on factors like TRIM status and drive fullness"}),"\n",(0,s.jsx)(n.li,{children:"External drives connected via USB may show different performance based on the USB port type (2.0, 3.0, etc.)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsxs)(n.p,{children:["The drive benchmarking functions return ",(0,s.jsx)(n.code,{children:"Result<T, Error>"})," types, allowing you to handle errors gracefully:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'match run_drive_benchmark() {\n    Ok(score) => println!("Benchmark score: {:.2}", score),\n    Err(e) => println!("Benchmark failed: {}", e),\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Common errors include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Permission issues when trying to write to protected directories"}),"\n",(0,s.jsx)(n.li,{children:"Insufficient disk space for the benchmark file"}),"\n",(0,s.jsx)(n.li,{children:"Drive disconnection during the benchmark"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The library includes fallback mechanisms to find writable locations for temporary files, but some errors may still occur in restricted environments."}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsxs)(n.p,{children:["For detailed API information, see the ",(0,s.jsx)(n.a,{href:"/catp2p/docs/api/benchmark/drives",children:"Drive Benchmarking API Reference"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>c});var i=r(6540);const s={},a=i.createContext(s);function t(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);