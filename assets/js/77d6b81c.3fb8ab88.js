"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[573],{6836:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api/benchmark/memory","title":"Memory Benchmarking API Reference","description":"This page provides detailed API reference for the memory benchmarking functionality in CatP2P.","source":"@site/docs/api/benchmark/memory.md","sourceDirName":"api/benchmark","slug":"/api/benchmark/memory","permalink":"/catp2p/docs/api/benchmark/memory","draft":false,"unlisted":false,"editUrl":"https://github.com/johnnyvillas/catp2p/tree/main/docs-site/docs/api/benchmark/memory.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Drive Benchmarking API Reference","permalink":"/catp2p/docs/api/benchmark/drives"},"next":{"title":"GPU Benchmarking API Reference","permalink":"/catp2p/docs/api/benchmark/gpu"}}');var i=n(4848),c=n(8453);const t={sidebar_position:2},o="Memory Benchmarking API Reference",d={},l=[{value:"Structures",id:"structures",level:2},{value:"<code>MemoryInfo</code>",id:"memoryinfo",level:3},{value:"Functions",id:"functions",level:2},{value:"Information Gathering",id:"information-gathering",level:3},{value:"Performance Testing",id:"performance-testing",level:3},{value:"Function Relationships",id:"function-relationships",level:3},{value:"Parameter Details",id:"parameter-details",level:3},{value:"Understanding Memory Benchmark Results",id:"understanding-memory-benchmark-results",level:2},{value:"Score Interpretation",id:"score-interpretation",level:3},{value:"Typical Score Ranges",id:"typical-score-ranges",level:3},{value:"Factors Affecting Benchmark Results",id:"factors-affecting-benchmark-results",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Benchmark Methodology",id:"benchmark-methodology",level:3},{value:"Score Calculation",id:"score-calculation",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Combining with CPU Benchmarks",id:"combining-with-cpu-benchmarks",level:3},{value:"Memory-to-CPU Ratio Analysis",id:"memory-to-cpu-ratio-analysis",level:3}];function a(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"memory-benchmarking-api-reference",children:"Memory Benchmarking API Reference"})}),"\n",(0,i.jsx)(r.p,{children:"This page provides detailed API reference for the memory benchmarking functionality in CatP2P."}),"\n",(0,i.jsx)(r.h2,{id:"structures",children:"Structures"}),"\n",(0,i.jsx)(r.h3,{id:"memoryinfo",children:(0,i.jsx)(r.code,{children:"MemoryInfo"})}),"\n",(0,i.jsx)(r.p,{children:"Contains detailed information about the system's memory."}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Field"}),(0,i.jsx)(r.th,{children:"Type"}),(0,i.jsx)(r.th,{children:"Description"}),(0,i.jsx)(r.th,{children:"Example Access"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"total_memory"})}),(0,i.jsx)(r.td,{children:"u64"}),(0,i.jsx)(r.td,{children:"Total physical memory in bytes"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"memory_info.total_memory"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"available_memory"})}),(0,i.jsx)(r.td,{children:"u64"}),(0,i.jsx)(r.td,{children:"Available memory in bytes"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"memory_info.available_memory"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"used_memory"})}),(0,i.jsx)(r.td,{children:"u64"}),(0,i.jsx)(r.td,{children:"Used memory in bytes (total - available)"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"memory_info.used_memory"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"usage_percent"})}),(0,i.jsx)(r.td,{children:"f64"}),(0,i.jsx)(r.td,{children:"Memory usage as a percentage (0.0 - 100.0)"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"memory_info.usage_percent"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"memory_per_core"})}),(0,i.jsx)(r.td,{children:"u64"}),(0,i.jsx)(r.td,{children:"Memory per CPU core in bytes"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"memory_info.memory_per_core"})})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(r.h3,{id:"information-gathering",children:"Information Gathering"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Function"}),(0,i.jsx)(r.th,{children:"Return Type"}),(0,i.jsx)(r.th,{children:"Description"}),(0,i.jsx)(r.th,{children:"Example Usage"}),(0,i.jsx)(r.th,{children:"Possible Errors"})]})}),(0,i.jsx)(r.tbody,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"get_memory_info()"})}),(0,i.jsx)(r.td,{children:"Result<MemoryInfo, Error>"}),(0,i.jsx)(r.td,{children:"Retrieves detailed information about the system's memory"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"let info = memory::get_memory_info()?;"})}),(0,i.jsx)(r.td,{children:"System access errors"})]})})]}),"\n",(0,i.jsx)(r.h3,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Function"}),(0,i.jsx)(r.th,{children:"Return Type"}),(0,i.jsx)(r.th,{children:"Description"}),(0,i.jsx)(r.th,{children:"Example Usage"}),(0,i.jsx)(r.th,{children:"Performance Impact"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"run_memory_benchmark()"})}),(0,i.jsx)(r.td,{children:"Result<f64, Error>"}),(0,i.jsx)(r.td,{children:"Runs a comprehensive memory benchmark and returns an overall score (higher is better)"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"let score = memory::run_memory_benchmark()?;"})}),(0,i.jsx)(r.td,{children:"High - runs all benchmarks, takes several seconds"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"run_allocation_benchmark()"})}),(0,i.jsx)(r.td,{children:"Result<f64, Error>"}),(0,i.jsx)(r.td,{children:"Tests memory allocation/deallocation performance (higher is better)"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"let score = memory::run_allocation_benchmark()?;"})}),(0,i.jsx)(r.td,{children:"Medium - allocates various memory sizes"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"run_read_write_benchmark()"})}),(0,i.jsx)(r.td,{children:"Result<f64, Error>"}),(0,i.jsx)(r.td,{children:"Tests sequential memory read/write performance (higher is better)"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"let score = memory::run_read_write_benchmark()?;"})}),(0,i.jsx)(r.td,{children:"High - allocates ~100MB buffer"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"run_random_access_benchmark()"})}),(0,i.jsx)(r.td,{children:"Result<f64, Error>"}),(0,i.jsx)(r.td,{children:"Tests random memory access performance (higher is better)"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"let score = memory::run_random_access_benchmark()?;"})}),(0,i.jsx)(r.td,{children:"High - allocates ~100MB buffer"})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"function-relationships",children:"Function Relationships"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Function"}),(0,i.jsx)(r.th,{children:"Related Functions"}),(0,i.jsx)(r.th,{children:"Notes"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"run_memory_benchmark()"})}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"run_allocation_benchmark()"}),", ",(0,i.jsx)(r.code,{children:"run_read_write_benchmark()"}),", ",(0,i.jsx)(r.code,{children:"run_random_access_benchmark()"})]}),(0,i.jsx)(r.td,{children:"Calls all three specific benchmarks and combines their scores"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"get_memory_info()"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"cpu::get_cpu_info()"})}),(0,i.jsx)(r.td,{children:"Often used together to get a complete system overview"})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"parameter-details",children:"Parameter Details"}),"\n",(0,i.jsx)(r.p,{children:"All memory benchmark functions take no parameters, making them simple to use."}),"\n",(0,i.jsx)(r.h2,{id:"understanding-memory-benchmark-results",children:"Understanding Memory Benchmark Results"}),"\n",(0,i.jsx)(r.h3,{id:"score-interpretation",children:"Score Interpretation"}),"\n",(0,i.jsx)(r.p,{children:"The memory benchmark functions return scores where higher values indicate better performance:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"run_allocation_benchmark()"}),": Measures how quickly memory can be allocated and deallocated"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"run_read_write_benchmark()"}),": Measures sequential memory access performance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"run_random_access_benchmark()"}),": Measures random memory access performance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"run_memory_benchmark()"}),": Combines the above scores into an overall memory performance score"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"typical-score-ranges",children:"Typical Score Ranges"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Memory Type"}),(0,i.jsx)(r.th,{children:"Allocation Score"}),(0,i.jsx)(r.th,{children:"Read/Write Score"}),(0,i.jsx)(r.th,{children:"Random Access Score"}),(0,i.jsx)(r.th,{children:"Overall Score"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"High-end DDR4/DDR5"}),(0,i.jsx)(r.td,{children:"800-1500+"}),(0,i.jsx)(r.td,{children:"500-1000+"}),(0,i.jsx)(r.td,{children:"300-800+"}),(0,i.jsx)(r.td,{children:"500-1000+"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Mid-range DDR4"}),(0,i.jsx)(r.td,{children:"500-800"}),(0,i.jsx)(r.td,{children:"300-500"}),(0,i.jsx)(r.td,{children:"200-300"}),(0,i.jsx)(r.td,{children:"300-500"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Basic DDR3/DDR4"}),(0,i.jsx)(r.td,{children:"300-500"}),(0,i.jsx)(r.td,{children:"200-300"}),(0,i.jsx)(r.td,{children:"100-200"}),(0,i.jsx)(r.td,{children:"200-300"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Low-power systems"}),(0,i.jsx)(r.td,{children:"100-300"}),(0,i.jsx)(r.td,{children:"50-200"}),(0,i.jsx)(r.td,{children:"50-100"}),(0,i.jsx)(r.td,{children:"50-200"})]})]})]}),"\n",(0,i.jsx)(r.p,{children:"Note: Actual scores can vary significantly based on specific hardware, system conditions, and memory configuration."}),"\n",(0,i.jsx)(r.h3,{id:"factors-affecting-benchmark-results",children:"Factors Affecting Benchmark Results"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Factor"}),(0,i.jsx)(r.th,{children:"Impact"}),(0,i.jsx)(r.th,{children:"Notes"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory Speed (MHz)"}),(0,i.jsx)(r.td,{children:"High"}),(0,i.jsx)(r.td,{children:"Higher frequency memory generally performs better"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory Channels"}),(0,i.jsx)(r.td,{children:"High"}),(0,i.jsx)(r.td,{children:"Dual/quad channel configurations improve bandwidth"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory Timings"}),(0,i.jsx)(r.td,{children:"Medium"}),(0,i.jsx)(r.td,{children:"Lower CAS latency and other timings improve performance"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"CPU Cache"}),(0,i.jsx)(r.td,{children:"High"}),(0,i.jsx)(r.td,{children:"Larger CPU caches can mask memory performance issues"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"System Load"}),(0,i.jsx)(r.td,{children:"Medium"}),(0,i.jsx)(r.td,{children:"Other processes using memory can affect benchmark results"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory Fragmentation"}),(0,i.jsx)(r.td,{children:"Medium"}),(0,i.jsx)(r.td,{children:"Long-running systems may have fragmented memory"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"NUMA Configuration"}),(0,i.jsx)(r.td,{children:"Medium"}),(0,i.jsx)(r.td,{children:"Non-Uniform Memory Access affects performance on multi-socket systems"})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,i.jsx)(r.h3,{id:"benchmark-methodology",children:"Benchmark Methodology"}),"\n",(0,i.jsx)(r.p,{children:"The memory benchmarking in CatP2P uses a combination of techniques to measure memory performance:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Allocation Benchmark"}),": Tests allocation and deallocation of memory blocks of various sizes"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Read/Write Benchmark"}),": Tests sequential reading and writing to a large memory buffer"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Random Access Benchmark"}),": Tests random access patterns across a large memory buffer"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Each benchmark is designed to:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Prevent compiler optimizations from skewing results"}),"\n",(0,i.jsx)(r.li,{children:"Provide consistent results across different hardware"}),"\n",(0,i.jsx)(r.li,{children:"Test realistic memory access patterns"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"score-calculation",children:"Score Calculation"}),"\n",(0,i.jsx)(r.p,{children:"All benchmark scores are calculated using the formula:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"score = 1000.0 / elapsed_time_in_seconds\n"})}),"\n",(0,i.jsx)(r.p,{children:"This means that faster execution results in higher scores. The overall memory benchmark score is the average of the three individual benchmark scores."}),"\n",(0,i.jsx)(r.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(r.p,{children:["The memory benchmarking functions use Rust's ",(0,i.jsx)(r.code,{children:"Result"})," type to handle errors gracefully. Common errors include:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:'Error::Resource("Failed to retrieve system memory information: {error}")'}),": System API errors"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:'Error::Resource("Memory allocation failed: {error}")'}),": Out of memory errors"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(r.p,{children:"When running memory benchmarks, be aware of these performance considerations:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Memory Usage"}),": The benchmarks allocate significant amounts of memory, especially the read/write and random access tests"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"System Load"}),": Running benchmarks on a system with high memory usage may affect results"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Warm-up Effects"}),": The first run of a benchmark may be slower due to cache and TLB warming"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Background Activity"}),": System background tasks can introduce variance in results"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"For the most accurate results:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Run benchmarks multiple times and average the results"}),"\n",(0,i.jsx)(r.li,{children:"Ensure the system has sufficient free memory"}),"\n",(0,i.jsx)(r.li,{children:"Close unnecessary applications and services"}),"\n",(0,i.jsx)(r.li,{children:"Be consistent in your testing environment"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,i.jsx)(r.h3,{id:"combining-with-cpu-benchmarks",children:"Combining with CPU Benchmarks"}),"\n",(0,i.jsx)(r.p,{children:"Memory and CPU performance are closely related. For a complete system assessment, combine memory benchmarks with CPU benchmarks:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::{memory, cpu};\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Get system information\n    let cpu_info = cpu::get_cpu_info()?;\n    let memory_info = memory::get_memory_info()?;\n    \n    println!("System Information:");\n    println!("CPU: {} ({} cores)", cpu_info.name, cpu_info.logical_cores);\n    println!("Memory: {:.2} GB", memory_info.total_memory as f64 / 1_073_741_824.0);\n    \n    // Run benchmarks\n    let cpu_score = cpu::run_cpu_benchmark()?;\n    let memory_score = memory::run_memory_benchmark()?;\n    \n    println!("Benchmark Results:");\n    println!("CPU Score: {:.2}", cpu_score);\n    println!("Memory Score: {:.2}", memory_score);\n    \n    // Calculate a combined system score\n    let system_score = (cpu_score * 0.6) + (memory_score * 0.4);\n    println!("Combined System Score: {:.2}", system_score);\n    \n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"memory-to-cpu-ratio-analysis",children:"Memory-to-CPU Ratio Analysis"}),"\n",(0,i.jsx)(r.p,{children:"The ratio of memory to CPU cores is an important metric for distributed computing:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::{memory, cpu};\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    let cpu_info = cpu::get_cpu_info()?;\n    let memory_info = memory::get_memory_info()?;\n    \n    // Calculate memory per core in GB\n    let memory_per_core_gb = memory_info.memory_per_core as f64 / 1_073_741_824.0;\n    \n    println!("Memory per CPU core: {:.2} GB", memory_per_core_gb);\n    \n    // Analyze the ratio\n    if memory_per_core_gb < 1.0 {\n        println!("Warning: Limited memory per core. Consider reducing parallel workloads.");\n    } else if memory_per_core_gb > 4.0 {\n        println!("Excellent memory-to-CPU ratio. Suitable for memory-intensive tasks.");\n    } else {\n        println!("Good memory-to-CPU ratio. Suitable for most workloads.");\n    }\n    \n    Ok(())\n}\n'})})]})}function h(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>o});var s=n(6540);const i={},c=s.createContext(i);function t(e){const r=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(c.Provider,{value:r},e.children)}}}]);