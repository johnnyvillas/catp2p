"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[9967],{4147:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/cpu-benchmarking","title":"CPU Benchmarking","description":"CatP2P provides comprehensive CPU benchmarking capabilities to help you understand your system\'s processing power. This is crucial for distributed computing tasks that may require significant CPU resources.","source":"@site/docs/guides/cpu-benchmarking.md","sourceDirName":"guides","slug":"/guides/cpu-benchmarking","permalink":"/catp2p/docs/guides/cpu-benchmarking","draft":false,"unlisted":false,"editUrl":"https://github.com/johnnyvillas/catp2p/tree/main/docs-site/docs/guides/cpu-benchmarking.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Benchmarking","permalink":"/catp2p/docs/category/benchmarking"}}');var s=r(4848),t=r(8453);const c={sidebar_position:1},o="CPU Benchmarking",a={},l=[{value:"CPU Information vs. Performance Testing",id:"cpu-information-vs-performance-testing",level:2},{value:"Getting CPU Information",id:"getting-cpu-information",level:2},{value:"Running CPU Performance Benchmarks",id:"running-cpu-performance-benchmarks",level:2},{value:"Single-Core vs. Multi-Core Performance",id:"single-core-vs-multi-core-performance",level:2},{value:"Floating-Point Performance",id:"floating-point-performance",level:2},{value:"Averaged Benchmarks for Consistency",id:"averaged-benchmarks-for-consistency",level:2},{value:"Understanding CPU Benchmark Results",id:"understanding-cpu-benchmark-results",level:2},{value:"Interpreting the Score",id:"interpreting-the-score",level:3},{value:"Understanding Multi-Core Performance",id:"understanding-multi-core-performance",level:3},{value:"Comparing Single-Core vs. Multi-Core Results",id:"comparing-single-core-vs-multi-core-results",level:3},{value:"Complete CPU Benchmarking Example",id:"complete-cpu-benchmarking-example",level:2},{value:"Best Practices for CPU Benchmarking",id:"best-practices-for-cpu-benchmarking",level:2},{value:"Using CPU Benchmark Results",id:"using-cpu-benchmark-results",level:2},{value:"Optimizing Multi-Core Performance",id:"optimizing-multi-core-performance",level:2},{value:"Future Improvements",id:"future-improvements",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"cpu-benchmarking",children:"CPU Benchmarking"})}),"\n",(0,s.jsx)(n.p,{children:"CatP2P provides comprehensive CPU benchmarking capabilities to help you understand your system's processing power. This is crucial for distributed computing tasks that may require significant CPU resources."}),"\n",(0,s.jsx)(n.h2,{id:"cpu-information-vs-performance-testing",children:"CPU Information vs. Performance Testing"}),"\n",(0,s.jsx)(n.p,{children:"CatP2P offers two approaches to CPU assessment:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Information Gathering"}),": Extracting CPU details like model name, core count, and current usage without running performance tests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Testing"}),": Running actual computations to measure real-world performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-cpu-information",children:"Getting CPU Information"}),"\n",(0,s.jsxs)(n.p,{children:["You can retrieve detailed CPU information using the ",(0,s.jsx)(n.code,{children:"get_cpu_info"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Get detailed CPU information\n    let cpu_info = cpu::get_cpu_info()?;\n    \n    // Access CPU information\n    println!("CPU Model: {}", cpu_info.name);\n    println!("CPU Vendor: {}", cpu_info.vendor);\n    println!("CPU Cores: {} (Logical: {})", cpu_info.cores, cpu_info.logical_cores);\n    if let Some(freq) = cpu_info.frequency {\n        println!("CPU Frequency: {} MHz", freq);\n    }\n    println!("Current CPU Usage: {:.2}%", cpu_info.usage);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This provides more comprehensive information than the previous approach using ",(0,s.jsx)(n.code,{children:"ResourceMonitor"}),", including the CPU model name, vendor, and frequency."]}),"\n",(0,s.jsx)(n.h2,{id:"running-cpu-performance-benchmarks",children:"Running CPU Performance Benchmarks"}),"\n",(0,s.jsx)(n.p,{children:"For a comprehensive assessment of CPU performance, you can use the benchmarking functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Run the overall CPU benchmark\n    let cpu_score = cpu::run_cpu_benchmark()?;\n    println!("CPU Benchmark Score: {:.2}", cpu_score);\n    \n    // The score represents overall CPU performance\n    // Higher scores indicate better performance\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"single-core-vs-multi-core-performance",children:"Single-Core vs. Multi-Core Performance"}),"\n",(0,s.jsx)(n.p,{children:"CatP2P allows you to test both single-core and multi-core performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Test single-core performance with different workloads\n    let iterations = 50_000_000;\n    let duration = cpu::run_single_core_benchmark(iterations)?;\n    println!("Single-core time: {:?}", duration);\n    \n    // Test multi-core performance with different thread counts\n    let threads = 4; // Use 4 CPU cores\n    let iterations_per_thread = 50_000_000;\n    let duration = cpu::run_multi_core_benchmark(threads, iterations_per_thread)?;\n    println!("Multi-core time with {} threads: {:?}", threads, duration);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"floating-point-performance",children:"Floating-Point Performance"}),"\n",(0,s.jsx)(n.p,{children:"CatP2P also provides a benchmark for floating-point operations, which are common in scientific computing and graphics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    let iterations = 10_000_000;\n    let duration = cpu::run_floating_point_benchmark(iterations)?;\n    println!("Floating-point benchmark: {:?}", duration);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"averaged-benchmarks-for-consistency",children:"Averaged Benchmarks for Consistency"}),"\n",(0,s.jsx)(n.p,{children:"To get more consistent results, you can run benchmarks multiple times and average the results:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Run the single-core benchmark 3 times and average the results\n    let avg_duration = cpu::run_averaged_benchmark(3, || {\n        cpu::run_single_core_benchmark(10_000_000)\n    })?;\n    \n    println!("Averaged single-core benchmark: {:?}", avg_duration);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"understanding-cpu-benchmark-results",children:"Understanding CPU Benchmark Results"}),"\n",(0,s.jsx)(n.p,{children:"The CPU benchmark in CatP2P measures several aspects of CPU performance:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raw computational power"}),": How quickly your CPU can perform calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-threading efficiency"}),": How well performance scales with multiple cores"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workload handling"}),": Performance under different types of computational tasks"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"interpreting-the-score",children:"Interpreting the Score"}),"\n",(0,s.jsx)(n.p,{children:"The overall CPU benchmark score is a composite value that represents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Higher scores indicate better CPU performance"}),"\n",(0,s.jsxs)(n.li,{children:["Scores are influenced by:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Number of CPU cores"}),"\n",(0,s.jsx)(n.li,{children:"CPU clock speed"}),"\n",(0,s.jsx)(n.li,{children:"CPU architecture and efficiency"}),"\n",(0,s.jsx)(n.li,{children:"Multi-threading capabilities"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"understanding-multi-core-performance",children:"Understanding Multi-Core Performance"}),"\n",(0,s.jsx)(n.p,{children:"When running multi-core benchmarks, you might observe that adding more cores doesn't always improve performance. In some cases, it might even decrease performance. This is due to several factors:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread Creation Overhead"}),": Creating and managing threads has a cost"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Contention"}),": Multiple cores accessing memory simultaneously can cause bottlenecks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Distribution"}),": The current implementation might not distribute work evenly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System Load"}),": Other processes running on your system can affect benchmark results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Coherence"}),": Maintaining consistent cache state across cores can add overhead"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For example, on an AMD Ryzen 7 3700X with 16 logical cores, we observed the following results:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Multi-core benchmark (1 cores): 442 ms\nMulti-core benchmark (2 cores): 432 ms\nMulti-core benchmark (4 cores): 486 ms\nMulti-core benchmark (8 cores): 605 ms\nMulti-core benchmark (16 cores): 918 ms\n"})}),"\n",(0,s.jsx)(n.p,{children:"This shows that performance actually degrades as more cores are added beyond 2 cores. The efficiency drops significantly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Cores | Ideal Speedup | Actual Speedup | Efficiency\n------|---------------|----------------|----------\n    1 |          1.00 |           1.00 |   100.00%\n    2 |          2.00 |           1.02 |    51.16%\n    4 |          4.00 |           0.91 |    22.74%\n    8 |          8.00 |           0.73 |     9.13%\n   16 |         16.00 |           0.48 |     3.01%\n"})}),"\n",(0,s.jsx)(n.p,{children:"This decreasing efficiency suggests that the benchmark workload is not well-suited for parallelization in its current form. This could be due to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"High synchronization overhead with the atomic counter"}),"\n",(0,s.jsx)(n.li,{children:"Memory access patterns causing cache contention"}),"\n",(0,s.jsx)(n.li,{children:"The workload being too simple to benefit from parallelization"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"comparing-single-core-vs-multi-core-results",children:"Comparing Single-Core vs. Multi-Core Results"}),"\n",(0,s.jsx)(n.p,{children:"By comparing single-core and multi-core benchmark results, you can understand:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The raw power of each CPU core"}),"\n",(0,s.jsx)(n.li,{children:"How efficiently your CPU scales with multiple threads"}),"\n",(0,s.jsx)(n.li,{children:"The optimal number of threads for your specific CPU"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For CPU-bound tasks in your application, you might want to limit the number of threads to the point where you see diminishing returns in the benchmark."}),"\n",(0,s.jsx)(n.h2,{id:"complete-cpu-benchmarking-example",children:"Complete CPU Benchmarking Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example that demonstrates all CPU benchmarking capabilities:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    println!("=== CatP2P CPU Information and Benchmarking ===\\n");\n    \n    // Get CPU information\n    let cpu_info = cpu::get_cpu_info()?;\n    \n    println!("CPU Model: {}", cpu_info.name);\n    println!("CPU Vendor: {}", cpu_info.vendor);\n    println!("CPU Cores: {} (Logical: {})", cpu_info.cores, cpu_info.logical_cores);\n    if let Some(freq) = cpu_info.frequency {\n        println!("CPU Frequency: {} MHz", freq);\n    }\n    println!("Current CPU Usage: {:.2}%", cpu_info.usage);\n    \n    // Run overall CPU benchmark\n    let cpu_score = cpu::run_cpu_benchmark()?;\n    println!("CPU Benchmark Score: {:.2}", cpu_score);\n    \n    // Run single-core benchmark\n    let iterations = 50_000_000;\n    let duration = cpu::run_single_core_benchmark(iterations)?;\n    println!("Single-core benchmark: {:?}", duration);\n    \n    // Run multi-core benchmark with different thread counts\n    let max_cores = cpu_info.logical_cores;\n    let iterations_per_thread = 50_000_000;\n    \n    for cores in [1, 2, 4, max_cores.min(8), max_cores] {\n        if cores > max_cores {\n            continue;\n        }\n        \n        let duration = cpu::run_multi_core_benchmark(cores, iterations_per_thread)?;\n        println!("Multi-core benchmark ({} cores): {:?}", cores, duration);\n    }\n    \n    // Run floating-point benchmark\n    let fp_iterations = 10_000_000;\n    let duration = cpu::run_floating_point_benchmark(fp_iterations)?;\n    println!("Floating-point benchmark: {:?}", duration);\n    \n    // Run averaged benchmarks\n    let avg_single = cpu::run_averaged_benchmark(3, || cpu::run_single_core_benchmark(10_000_000))?;\n    println!("Averaged single-core benchmark: {:?}", avg_single);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-cpu-benchmarking",children:"Best Practices for CPU Benchmarking"}),"\n",(0,s.jsx)(n.p,{children:"To get the most accurate results from your CPU benchmarks:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Run benchmarks when the system is idle"}),": Close other applications and background processes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Run benchmarks multiple times"}),": Take the average of several runs to account for variations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Be consistent with system conditions"}),": Power settings, CPU frequency scaling, and temperature can affect results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interpret results in context"}),": Compare results only between similar hardware and configurations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider your specific workload"}),": The benchmark is a general test and might not reflect the performance of your specific application"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-cpu-benchmark-results",children:"Using CPU Benchmark Results"}),"\n",(0,s.jsx)(n.p,{children:"The results from CPU benchmarking can help you:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Determine if your system is suitable for CPU-intensive distributed tasks"}),"\n",(0,s.jsx)(n.li,{children:"Configure optimal thread counts for parallel processing"}),"\n",(0,s.jsx)(n.li,{children:"Compare your node's capabilities with other nodes in the network"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate CPU resource limits in your CatP2P configuration"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"optimizing-multi-core-performance",children:"Optimizing Multi-Core Performance"}),"\n",(0,s.jsx)(n.p,{children:"If you're developing CPU-intensive applications with CatP2P, consider these strategies to improve multi-core performance:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduce synchronization points"}),": Minimize the use of locks, atomic operations, and shared data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use larger work chunks"}),": Increase the amount of work done between synchronization points"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement work stealing"}),': Allow idle threads to "steal" work from busy threads']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider NUMA awareness"}),": On systems with Non-Uniform Memory Access, ensure threads work with memory close to their CPU"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use thread-local storage"}),": Minimize contention by giving each thread its own data structures"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,s.jsx)(n.p,{children:"The CatP2P team is working on improving the CPU benchmarking functionality:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Better work distribution for multi-core benchmarks"}),"\n",(0,s.jsx)(n.li,{children:"More specialized benchmarks for different types of workloads"}),"\n",(0,s.jsx)(n.li,{children:"Visualization tools to help interpret benchmark results"}),"\n",(0,s.jsx)(n.li,{children:"Integration with the task scheduler to optimize task allocation"}),"\n",(0,s.jsx)(n.li,{children:"SIMD (Single Instruction, Multiple Data) benchmarks to test vector processing capabilities"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);