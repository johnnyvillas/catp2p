"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[8281],{4121:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Benchmarking/cpu-benchmarking","title":"CPU Benchmarking","description":"CatP2P provides comprehensive CPU benchmarking capabilities to help you understand your system\'s processing power. This is crucial for distributed computing tasks that may require significant CPU resources.","source":"@site/docs/Benchmarking/cpu-benchmarking.md","sourceDirName":"Benchmarking","slug":"/Benchmarking/cpu-benchmarking","permalink":"/catp2p/docs/Benchmarking/cpu-benchmarking","draft":false,"unlisted":false,"editUrl":"https://github.com/johnnyvillas/catp2p/tree/main/docs-site/docs/Benchmarking/cpu-benchmarking.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Benchmarking","permalink":"/catp2p/docs/category/benchmarking"},"next":{"title":"Memory Benchmarking","permalink":"/catp2p/docs/Benchmarking/memory-benchmarking"}}');var s=r(4848),t=r(8453);const c={sidebar_position:1},o="CPU Benchmarking",l={},a=[{value:"CPU Information vs. Performance Testing",id:"cpu-information-vs-performance-testing",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Structures",id:"structures",level:3},{value:"<code>CpuInfo</code>",id:"cpuinfo",level:4},{value:"Functions",id:"functions",level:3},{value:"Information Gathering",id:"information-gathering",level:4},{value:"Performance Testing",id:"performance-testing",level:4},{value:"Function Relationships",id:"function-relationships",level:3},{value:"Parameter Details",id:"parameter-details",level:3},{value:"Getting CPU Information",id:"getting-cpu-information",level:2},{value:"Running CPU Performance Benchmarks",id:"running-cpu-performance-benchmarks",level:2},{value:"Single-Core vs. Multi-Core Performance",id:"single-core-vs-multi-core-performance",level:2},{value:"Floating-Point Performance",id:"floating-point-performance",level:2},{value:"Averaged Benchmarks for Consistency",id:"averaged-benchmarks-for-consistency",level:2},{value:"Understanding CPU Benchmark Results",id:"understanding-cpu-benchmark-results",level:2},{value:"Interpreting the Score",id:"interpreting-the-score",level:3},{value:"Understanding Multi-Core Performance",id:"understanding-multi-core-performance",level:3},{value:"Comparing Single-Core vs. Multi-Core Results",id:"comparing-single-core-vs-multi-core-results",level:3},{value:"Complete CPU Benchmarking Example",id:"complete-cpu-benchmarking-example",level:2},{value:"Best Practices for CPU Benchmarking",id:"best-practices-for-cpu-benchmarking",level:2},{value:"Using CPU Benchmark Results",id:"using-cpu-benchmark-results",level:2},{value:"Optimizing Multi-Core Performance",id:"optimizing-multi-core-performance",level:2},{value:"Future Improvements",id:"future-improvements",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"cpu-benchmarking",children:"CPU Benchmarking"})}),"\n",(0,s.jsx)(n.p,{children:"CatP2P provides comprehensive CPU benchmarking capabilities to help you understand your system's processing power. This is crucial for distributed computing tasks that may require significant CPU resources."}),"\n",(0,s.jsx)(n.h2,{id:"cpu-information-vs-performance-testing",children:"CPU Information vs. Performance Testing"}),"\n",(0,s.jsx)(n.p,{children:"CatP2P offers two approaches to CPU assessment:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Information Gathering"}),": Extracting CPU details like model name, core count, and current usage without running performance tests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Testing"}),": Running actual computations to measure real-world performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(n.h3,{id:"structures",children:"Structures"}),"\n",(0,s.jsx)(n.h4,{id:"cpuinfo",children:(0,s.jsx)(n.code,{children:"CpuInfo"})}),"\n",(0,s.jsx)(n.p,{children:"Contains detailed information about the system's CPU."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Field"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Example Access"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"name"})}),(0,s.jsx)(n.td,{children:"String"}),(0,s.jsx)(n.td,{children:"The name/model of the CPU"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cpu_info.name"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cores"})}),(0,s.jsx)(n.td,{children:"Unsigned integer"}),(0,s.jsx)(n.td,{children:"The number of physical cores"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cpu_info.cores"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"logical_cores"})}),(0,s.jsx)(n.td,{children:"Unsigned integer"}),(0,s.jsx)(n.td,{children:"The number of logical processors (including hyperthreading)"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cpu_info.logical_cores"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"usage"})}),(0,s.jsx)(n.td,{children:"Floating-point number"}),(0,s.jsx)(n.td,{children:"Current CPU usage as a percentage (0-100)"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cpu_info.usage"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"vendor"})}),(0,s.jsx)(n.td,{children:"String"}),(0,s.jsx)(n.td,{children:'CPU vendor (e.g., "Intel", "AMD")'}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cpu_info.vendor"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"frequency"})}),(0,s.jsx)(n.td,{children:"Optional unsigned 64-bit integer"}),(0,s.jsx)(n.td,{children:"CPU frequency in MHz, if available"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"if let Some(freq) = cpu_info.frequency { ... }"})})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.h4,{id:"information-gathering",children:"Information Gathering"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Return Type"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Example Usage"}),(0,s.jsx)(n.th,{children:"Possible Errors"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"get_cpu_info()"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"CpuInfo"})," structure or Error"]}),(0,s.jsx)(n.td,{children:"Retrieves detailed information about the system's CPU"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"let info = cpu::get_cpu_info()?;"})}),(0,s.jsx)(n.td,{children:"Failed to retrieve CPU information"})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Return Type"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Example Usage"}),(0,s.jsx)(n.th,{children:"Performance Impact"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_cpu_benchmark()"})}),(0,s.jsx)(n.td,{children:"Floating-point score or Error"}),(0,s.jsx)(n.td,{children:"Runs a comprehensive CPU benchmark and returns an overall score (higher is better)"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"let score = cpu::run_cpu_benchmark()?;"})}),(0,s.jsx)(n.td,{children:"High - utilizes all CPU cores"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_single_core_benchmark(iterations: u64)"})}),(0,s.jsx)(n.td,{children:"Duration or Error"}),(0,s.jsx)(n.td,{children:"Measures performance of a single CPU core with specified iterations"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"let duration = cpu::run_single_core_benchmark(50_000_000)?;"})}),(0,s.jsx)(n.td,{children:"Medium - runs on a single core"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_multi_core_benchmark(threads: usize, iterations_per_thread: u64)"})}),(0,s.jsx)(n.td,{children:"Duration or Error"}),(0,s.jsx)(n.td,{children:"Measures performance with multiple threads and specified iterations per thread"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"let duration = cpu::run_multi_core_benchmark(4, 50_000_000)?;"})}),(0,s.jsx)(n.td,{children:"High - utilizes specified number of cores"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_floating_point_benchmark(iterations: u64)"})}),(0,s.jsx)(n.td,{children:"Duration or Error"}),(0,s.jsx)(n.td,{children:"Measures floating-point computation performance"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"let duration = cpu::run_floating_point_benchmark(10_000_000)?;"})}),(0,s.jsx)(n.td,{children:"Medium - primarily tests FPU"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_averaged_benchmark(iterations: usize, benchmark_fn: F)"})}),(0,s.jsx)(n.td,{children:"Duration or Error"}),(0,s.jsx)(n.td,{children:"Runs a benchmark multiple times and returns the average duration"}),(0,s.jsx)(n.td,{children:"`let avg = cpu::run_averaged_benchmark(3,"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"function-relationships",children:"Function Relationships"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Related Functions"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_cpu_benchmark()"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"run_single_core_benchmark()"}),", ",(0,s.jsx)(n.code,{children:"run_multi_core_benchmark()"})]}),(0,s.jsx)(n.td,{children:"Provides an overall CPU score based on performance across all cores"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_averaged_benchmark()"})}),(0,s.jsx)(n.td,{children:"Any benchmark function"}),(0,s.jsx)(n.td,{children:"Takes a closure that returns a benchmark result and runs it multiple times"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"get_cpu_info()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"memory::get_memory_info()"})}),(0,s.jsx)(n.td,{children:"Often used together to get a complete system overview"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"parameter-details",children:"Parameter Details"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Recommended Values"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_single_core_benchmark()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"iterations"})}),(0,s.jsx)(n.td,{children:"Number of computational iterations to perform"}),(0,s.jsx)(n.td,{children:"10,000,000 to 100,000,000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_multi_core_benchmark()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"threads"})}),(0,s.jsx)(n.td,{children:"Number of threads to use"}),(0,s.jsx)(n.td,{children:"1 to number of logical cores"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_multi_core_benchmark()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"iterations_per_thread"})}),(0,s.jsx)(n.td,{children:"Iterations per thread"}),(0,s.jsx)(n.td,{children:"10,000,000 to 100,000,000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_floating_point_benchmark()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"iterations"})}),(0,s.jsx)(n.td,{children:"Number of floating-point operations to perform"}),(0,s.jsx)(n.td,{children:"1,000,000 to 50,000,000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"run_averaged_benchmark()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"iterations"})}),(0,s.jsx)(n.td,{children:"Number of times to run the benchmark"}),(0,s.jsx)(n.td,{children:"3 to 10"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"getting-cpu-information",children:"Getting CPU Information"}),"\n",(0,s.jsxs)(n.p,{children:["You can retrieve detailed CPU information using the ",(0,s.jsx)(n.code,{children:"get_cpu_info"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Get detailed CPU information\n    let cpu_info = cpu::get_cpu_info()?;\n    \n    // Access CPU information\n    println!("CPU Model: {}", cpu_info.name);\n    println!("CPU Vendor: {}", cpu_info.vendor);\n    println!("CPU Cores: {} (Logical: {})", cpu_info.cores, cpu_info.logical_cores);\n    if let Some(freq) = cpu_info.frequency {\n        println!("CPU Frequency: {} MHz", freq);\n    }\n    println!("Current CPU Usage: {:.2}%", cpu_info.usage);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This provides more comprehensive information than the previous approach using ",(0,s.jsx)(n.code,{children:"ResourceMonitor"}),", including the CPU model name, vendor, and frequency."]}),"\n",(0,s.jsx)(n.h2,{id:"running-cpu-performance-benchmarks",children:"Running CPU Performance Benchmarks"}),"\n",(0,s.jsx)(n.p,{children:"For a comprehensive assessment of CPU performance, you can use the benchmarking functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Run the overall CPU benchmark\n    let cpu_score = cpu::run_cpu_benchmark()?;\n    println!("CPU Benchmark Score: {:.2}", cpu_score);\n    \n    // The score represents overall CPU performance\n    // Higher scores indicate better performance\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"single-core-vs-multi-core-performance",children:"Single-Core vs. Multi-Core Performance"}),"\n",(0,s.jsx)(n.p,{children:"CatP2P allows you to test both single-core and multi-core performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Test single-core performance with different workloads\n    let iterations = 50_000_000;\n    let duration = cpu::run_single_core_benchmark(iterations)?;\n    println!("Single-core time: {:?}", duration);\n    \n    // Test multi-core performance with different thread counts\n    let threads = 4; // Use 4 CPU cores\n    let iterations_per_thread = 50_000_000;\n    let duration = cpu::run_multi_core_benchmark(threads, iterations_per_thread)?;\n    println!("Multi-core time with {} threads: {:?}", threads, duration);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"floating-point-performance",children:"Floating-Point Performance"}),"\n",(0,s.jsx)(n.p,{children:"CatP2P also provides a benchmark for floating-point operations, which are common in scientific computing and graphics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    let iterations = 10_000_000;\n    let duration = cpu::run_floating_point_benchmark(iterations)?;\n    println!("Floating-point benchmark: {:?}", duration);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"averaged-benchmarks-for-consistency",children:"Averaged Benchmarks for Consistency"}),"\n",(0,s.jsx)(n.p,{children:"To get more consistent results, you can run benchmarks multiple times and average the results:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Run the single-core benchmark 3 times and average the results\n    let avg_duration = cpu::run_averaged_benchmark(3, || {\n        cpu::run_single_core_benchmark(10_000_000)\n    })?;\n    \n    println!("Averaged single-core benchmark: {:?}", avg_duration);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"understanding-cpu-benchmark-results",children:"Understanding CPU Benchmark Results"}),"\n",(0,s.jsx)(n.p,{children:"The CPU benchmark in CatP2P measures several aspects of CPU performance:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raw computational power"}),": How quickly your CPU can perform calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-threading efficiency"}),": How well performance scales with multiple cores"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workload handling"}),": Performance under different types of computational tasks"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"interpreting-the-score",children:"Interpreting the Score"}),"\n",(0,s.jsx)(n.p,{children:"The overall CPU benchmark score is a composite value that represents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Higher scores indicate better CPU performance"}),"\n",(0,s.jsxs)(n.li,{children:["Scores are influenced by:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Number of CPU cores"}),"\n",(0,s.jsx)(n.li,{children:"CPU clock speed"}),"\n",(0,s.jsx)(n.li,{children:"CPU architecture and efficiency"}),"\n",(0,s.jsx)(n.li,{children:"Multi-threading capabilities"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"understanding-multi-core-performance",children:"Understanding Multi-Core Performance"}),"\n",(0,s.jsx)(n.p,{children:"When running multi-core benchmarks, you might observe that adding more cores doesn't always improve performance. In some cases, it might even decrease performance. This is due to several factors:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread Creation Overhead"}),": Creating and managing threads has a cost"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Contention"}),": Multiple cores accessing memory simultaneously can cause bottlenecks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Distribution"}),": The current implementation might not distribute work evenly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System Load"}),": Other processes running on your system can affect benchmark results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Coherence"}),": Maintaining consistent cache state across cores can add overhead"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For example, on an AMD Ryzen 7 3700X with 16 logical cores, we observed the following results:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Multi-core benchmark (1 cores): 442 ms\nMulti-core benchmark (2 cores): 432 ms\nMulti-core benchmark (4 cores): 486 ms\nMulti-core benchmark (8 cores): 605 ms\nMulti-core benchmark (16 cores): 918 ms\n"})}),"\n",(0,s.jsx)(n.p,{children:"This shows that performance actually degrades as more cores are added beyond 2 cores. The efficiency drops significantly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Cores | Ideal Speedup | Actual Speedup | Efficiency\n------|---------------|----------------|----------\n    1 |          1.00 |           1.00 |   100.00%\n    2 |          2.00 |           1.02 |    51.16%\n    4 |          4.00 |           0.91 |    22.74%\n    8 |          8.00 |           0.73 |     9.13%\n   16 |         16.00 |           0.48 |     3.01%\n"})}),"\n",(0,s.jsx)(n.p,{children:"This decreasing efficiency suggests that the benchmark workload is not well-suited for parallelization in its current form. This could be due to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"High synchronization overhead with the atomic counter"}),"\n",(0,s.jsx)(n.li,{children:"Memory access patterns causing cache contention"}),"\n",(0,s.jsx)(n.li,{children:"The workload being too simple to benefit from parallelization"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"comparing-single-core-vs-multi-core-results",children:"Comparing Single-Core vs. Multi-Core Results"}),"\n",(0,s.jsx)(n.p,{children:"By comparing single-core and multi-core benchmark results, you can understand:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The raw power of each CPU core"}),"\n",(0,s.jsx)(n.li,{children:"How efficiently your CPU scales with multiple threads"}),"\n",(0,s.jsx)(n.li,{children:"The optimal number of threads for your specific CPU"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For CPU-bound tasks in your application, you might want to limit the number of threads to the point where you see diminishing returns in the benchmark."}),"\n",(0,s.jsx)(n.h2,{id:"complete-cpu-benchmarking-example",children:"Complete CPU Benchmarking Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example that demonstrates all CPU benchmarking capabilities:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use catp2p::benchmark::cpu;\nuse catp2p::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    println!("=== CatP2P CPU Information and Benchmarking ===\\n");\n    \n    // Get CPU information\n    let cpu_info = cpu::get_cpu_info()?;\n    \n    println!("CPU Model: {}", cpu_info.name);\n    println!("CPU Vendor: {}", cpu_info.vendor);\n    println!("CPU Cores: {} (Logical: {})", cpu_info.cores, cpu_info.logical_cores);\n    if let Some(freq) = cpu_info.frequency {\n        println!("CPU Frequency: {} MHz", freq);\n    }\n    println!("Current CPU Usage: {:.2}%", cpu_info.usage);\n    \n    // Run overall CPU benchmark\n    let cpu_score = cpu::run_cpu_benchmark()?;\n    println!("CPU Benchmark Score: {:.2}", cpu_score);\n    \n    // Run single-core benchmark\n    let iterations = 50_000_000;\n    let duration = cpu::run_single_core_benchmark(iterations)?;\n    println!("Single-core benchmark: {:?}", duration);\n    \n    // Run multi-core benchmark with different thread counts\n    let max_cores = cpu_info.logical_cores;\n    let iterations_per_thread = 50_000_000;\n    \n    for cores in [1, 2, 4, max_cores.min(8), max_cores] {\n        if cores > max_cores {\n            continue;\n        }\n        \n        let duration = cpu::run_multi_core_benchmark(cores, iterations_per_thread)?;\n        println!("Multi-core benchmark ({} cores): {:?}", cores, duration);\n    }\n    \n    // Run floating-point benchmark\n    let fp_iterations = 10_000_000;\n    let duration = cpu::run_floating_point_benchmark(fp_iterations)?;\n    println!("Floating-point benchmark: {:?}", duration);\n    \n    // Run averaged benchmarks\n    let avg_single = cpu::run_averaged_benchmark(3, || cpu::run_single_core_benchmark(10_000_000))?;\n    println!("Averaged single-core benchmark: {:?}", avg_single);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-cpu-benchmarking",children:"Best Practices for CPU Benchmarking"}),"\n",(0,s.jsx)(n.p,{children:"To get the most accurate results from your CPU benchmarks:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Run benchmarks when the system is idle"}),": Close other applications and background processes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Run benchmarks multiple times"}),": Take the average of several runs to account for variations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Be consistent with system conditions"}),": Power settings, CPU frequency scaling, and temperature can affect results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interpret results in context"}),": Compare results only between similar hardware and configurations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider your specific workload"}),": The benchmark is a general test and might not reflect the performance of your specific application"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-cpu-benchmark-results",children:"Using CPU Benchmark Results"}),"\n",(0,s.jsx)(n.p,{children:"The results from CPU benchmarking can help you:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Determine if your system is suitable for CPU-intensive distributed tasks"}),"\n",(0,s.jsx)(n.li,{children:"Configure optimal thread counts for parallel processing"}),"\n",(0,s.jsx)(n.li,{children:"Compare your node's capabilities with other nodes in the network"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate CPU resource limits in your CatP2P configuration"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"optimizing-multi-core-performance",children:"Optimizing Multi-Core Performance"}),"\n",(0,s.jsx)(n.p,{children:"If you're developing CPU-intensive applications with CatP2P, consider these strategies to improve multi-core performance:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduce synchronization points"}),": Minimize the use of locks, atomic operations, and shared data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use larger work chunks"}),": Increase the amount of work done between synchronization points"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement work stealing"}),': Allow idle threads to "steal" work from busy threads']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider NUMA awareness"}),": On systems with Non-Uniform Memory Access, ensure threads work with memory close to their CPU"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use thread-local storage"}),": Minimize contention by giving each thread its own data structures"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,s.jsx)(n.p,{children:"The CatP2P team is working on improving the CPU benchmarking functionality:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Better work distribution for multi-core benchmarks"}),"\n",(0,s.jsx)(n.li,{children:"More specialized benchmarks for different types of workloads"}),"\n",(0,s.jsx)(n.li,{children:"Visualization tools to help interpret benchmark results"}),"\n",(0,s.jsx)(n.li,{children:"Integration with the task scheduler to optimize task allocation"}),"\n",(0,s.jsx)(n.li,{children:"SIMD (Single Instruction, Multiple Data) benchmarks to test vector processing capabilities"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);