"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[115],{877:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"Benchmarking/memory-benchmarking","title":"Memory Benchmarking","description":"CatP2P provides comprehensive memory benchmarking capabilities to help you understand your system\'s memory performance. This is crucial for distributed computing tasks that may require significant memory resources.","source":"@site/docs/Benchmarking/memory-benchmarking.md","sourceDirName":"Benchmarking","slug":"/Benchmarking/memory-benchmarking","permalink":"/catp2p/docs/Benchmarking/memory-benchmarking","draft":false,"unlisted":false,"editUrl":"https://github.com/johnnyvillas/catp2p/tree/main/docs-site/docs/Benchmarking/memory-benchmarking.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"CPU Benchmarking","permalink":"/catp2p/docs/Benchmarking/cpu-benchmarking"}}');var s=n(4848),i=n(8453);const t={sidebar_position:2},c="Memory Benchmarking",a={},m=[{value:"Memory Information vs. Performance Testing",id:"memory-information-vs-performance-testing",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Structures",id:"structures",level:3},{value:"<code>MemoryInfo</code>",id:"memoryinfo",level:4},{value:"Functions",id:"functions",level:3},{value:"Information Gathering",id:"information-gathering",level:4},{value:"Performance Testing",id:"performance-testing",level:4},{value:"Function Relationships",id:"function-relationships",level:3},{value:"Getting Memory Information",id:"getting-memory-information",level:2},{value:"Running Memory Performance Benchmarks",id:"running-memory-performance-benchmarks",level:2},{value:"Memory Benchmark Components",id:"memory-benchmark-components",level:2},{value:"1. Allocation Benchmark",id:"1-allocation-benchmark",level:3},{value:"2. Read/Write Benchmark",id:"2-readwrite-benchmark",level:3},{value:"3. Random Access Benchmark",id:"3-random-access-benchmark",level:3},{value:"Understanding Memory Benchmark Results",id:"understanding-memory-benchmark-results",level:2},{value:"Interpreting the Score",id:"interpreting-the-score",level:3},{value:"Typical Benchmark Results",id:"typical-benchmark-results",level:3},{value:"Factors Affecting Memory Performance",id:"factors-affecting-memory-performance",level:3},{value:"Complete Memory Benchmarking Example",id:"complete-memory-benchmarking-example",level:2},{value:"Best Practices for Memory Benchmarking",id:"best-practices-for-memory-benchmarking",level:2},{value:"Using Memory Benchmark Results",id:"using-memory-benchmark-results",level:2},{value:"Memory-to-CPU Ratio",id:"memory-to-cpu-ratio",level:2},{value:"Future Improvements",id:"future-improvements",level:2}];function l(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"memory-benchmarking",children:"Memory Benchmarking"})}),"\n",(0,s.jsx)(r.p,{children:"CatP2P provides comprehensive memory benchmarking capabilities to help you understand your system's memory performance. This is crucial for distributed computing tasks that may require significant memory resources."}),"\n",(0,s.jsx)(r.h2,{id:"memory-information-vs-performance-testing",children:"Memory Information vs. Performance Testing"}),"\n",(0,s.jsx)(r.p,{children:"CatP2P offers two approaches to memory assessment:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Information Gathering"}),": Extracting memory details like total capacity, available memory, and usage without running performance tests"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Performance Testing"}),": Running actual memory operations to measure real-world performance"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(r.h3,{id:"structures",children:"Structures"}),"\n",(0,s.jsx)(r.h4,{id:"memoryinfo",children:(0,s.jsx)(r.code,{children:"MemoryInfo"})}),"\n",(0,s.jsx)(r.p,{children:"Contains detailed information about the system's memory."}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Field"}),(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Description"}),(0,s.jsx)(r.th,{children:"Example Access"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"total_memory"})}),(0,s.jsx)(r.td,{children:"Unsigned 64-bit integer"}),(0,s.jsx)(r.td,{children:"Total physical memory in bytes"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"memory_info.total_memory"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"available_memory"})}),(0,s.jsx)(r.td,{children:"Unsigned 64-bit integer"}),(0,s.jsx)(r.td,{children:"Available memory in bytes"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"memory_info.available_memory"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"used_memory"})}),(0,s.jsx)(r.td,{children:"Unsigned 64-bit integer"}),(0,s.jsx)(r.td,{children:"Used memory in bytes (total - available)"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"memory_info.used_memory"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"usage_percent"})}),(0,s.jsx)(r.td,{children:"Floating-point number"}),(0,s.jsx)(r.td,{children:"Memory usage as a percentage (0.0 - 100.0)"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"memory_info.usage_percent"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"memory_per_core"})}),(0,s.jsx)(r.td,{children:"Unsigned 64-bit integer"}),(0,s.jsx)(r.td,{children:"Memory per CPU core in bytes"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"memory_info.memory_per_core"})})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(r.h4,{id:"information-gathering",children:"Information Gathering"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Function"}),(0,s.jsx)(r.th,{children:"Return Type"}),(0,s.jsx)(r.th,{children:"Description"}),(0,s.jsx)(r.th,{children:"Example Usage"}),(0,s.jsx)(r.th,{children:"Possible Errors"})]})}),(0,s.jsx)(r.tbody,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"get_memory_info()"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"MemoryInfo"})," structure or Error"]}),(0,s.jsx)(r.td,{children:"Retrieves detailed information about the system's memory"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"let info = memory::get_memory_info()?;"})}),(0,s.jsx)(r.td,{children:"System access errors"})]})})]}),"\n",(0,s.jsx)(r.h4,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Function"}),(0,s.jsx)(r.th,{children:"Return Type"}),(0,s.jsx)(r.th,{children:"Description"}),(0,s.jsx)(r.th,{children:"Example Usage"}),(0,s.jsx)(r.th,{children:"Performance Impact"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"run_memory_benchmark()"})}),(0,s.jsx)(r.td,{children:"Floating-point score or Error"}),(0,s.jsx)(r.td,{children:"Runs a comprehensive memory benchmark and returns an overall score (higher is better)"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"let score = memory::run_memory_benchmark()?;"})}),(0,s.jsx)(r.td,{children:"High - runs all benchmarks, takes several seconds"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"run_allocation_benchmark()"})}),(0,s.jsx)(r.td,{children:"Floating-point score or Error"}),(0,s.jsx)(r.td,{children:"Tests memory allocation/deallocation performance (higher is better)"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"let score = memory::run_allocation_benchmark()?;"})}),(0,s.jsx)(r.td,{children:"Medium - allocates various memory sizes"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"run_read_write_benchmark()"})}),(0,s.jsx)(r.td,{children:"Floating-point score or Error"}),(0,s.jsx)(r.td,{children:"Tests sequential memory read/write performance (higher is better)"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"let score = memory::run_read_write_benchmark()?;"})}),(0,s.jsx)(r.td,{children:"High - allocates ~100MB buffer"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"run_random_access_benchmark()"})}),(0,s.jsx)(r.td,{children:"Floating-point score or Error"}),(0,s.jsx)(r.td,{children:"Tests random memory access performance (higher is better)"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"let score = memory::run_random_access_benchmark()?;"})}),(0,s.jsx)(r.td,{children:"High - allocates ~100MB buffer"})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"function-relationships",children:"Function Relationships"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Function"}),(0,s.jsx)(r.th,{children:"Related Functions"}),(0,s.jsx)(r.th,{children:"Notes"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"run_memory_benchmark()"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"run_allocation_benchmark()"}),", ",(0,s.jsx)(r.code,{children:"run_read_write_benchmark()"}),", ",(0,s.jsx)(r.code,{children:"run_random_access_benchmark()"})]}),(0,s.jsx)(r.td,{children:"Calls all three specific benchmarks and combines their scores"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"get_memory_info()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"cpu::get_cpu_info()"})}),(0,s.jsx)(r.td,{children:"Often used together to get a complete system overview"})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"getting-memory-information",children:"Getting Memory Information"}),"\n",(0,s.jsx)(r.p,{children:"CatP2P provides a dedicated function to retrieve detailed memory information:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::memory;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Get memory information\n    let memory_info = memory::get_memory_info()?;\n    \n    // Display memory information\n    println!("Total Memory: {} bytes", memory_info.total_memory);\n    println!("Available Memory: {} bytes", memory_info.available_memory);\n    println!("Used Memory: {} bytes", memory_info.used_memory);\n    println!("Memory Usage: {:.2}%", memory_info.usage_percent);\n    println!("Memory per CPU core: {} bytes", memory_info.memory_per_core);\n    \n    // Convert to more readable format\n    println!("Total Memory: {:.2} GB", bytes_to_gb(memory_info.total_memory));\n    println!("Available Memory: {:.2} GB", bytes_to_gb(memory_info.available_memory));\n    println!("Used Memory: {:.2} GB", bytes_to_gb(memory_info.used_memory));\n    println!("Memory per CPU core: {:.2} GB", bytes_to_gb(memory_info.memory_per_core));\n    \n    Ok(())\n}\n\n// Helper function to convert bytes to gigabytes\nfn bytes_to_gb(bytes: u64) -> f64 {\n    bytes as f64 / 1_073_741_824.0 // 1024^3\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"running-memory-performance-benchmarks",children:"Running Memory Performance Benchmarks"}),"\n",(0,s.jsx)(r.p,{children:"For a comprehensive assessment of memory performance, you can use the benchmarking functions:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::memory;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    // Run the overall memory benchmark\n    let memory_score = memory::run_memory_benchmark()?;\n    println!("Memory Benchmark Score: {:.2}", memory_score);\n    \n    // The score represents overall memory performance\n    // Higher scores indicate better performance\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"memory-benchmark-components",children:"Memory Benchmark Components"}),"\n",(0,s.jsx)(r.p,{children:"CatP2P's memory benchmark consists of three key components that test different aspects of memory performance:"}),"\n",(0,s.jsx)(r.h3,{id:"1-allocation-benchmark",children:"1. Allocation Benchmark"}),"\n",(0,s.jsx)(r.p,{children:"This benchmark tests how quickly your system can allocate and deallocate memory of various sizes:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::memory;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    let allocation_score = memory::run_allocation_benchmark()?;\n    println!("Memory Allocation Score: {:.2}", allocation_score);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"The allocation benchmark is particularly important for applications that frequently create and destroy objects or buffers."}),"\n",(0,s.jsx)(r.h3,{id:"2-readwrite-benchmark",children:"2. Read/Write Benchmark"}),"\n",(0,s.jsx)(r.p,{children:"This benchmark tests sequential memory access performance by writing to and reading from a large buffer:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::memory;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    let rw_score = memory::run_read_write_benchmark()?;\n    println!("Memory Read/Write Score: {:.2}", rw_score);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"The read/write benchmark is relevant for tasks that process large datasets sequentially, such as video processing or large file operations."}),"\n",(0,s.jsx)(r.h3,{id:"3-random-access-benchmark",children:"3. Random Access Benchmark"}),"\n",(0,s.jsx)(r.p,{children:"This benchmark tests how quickly your system can access memory at random locations:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::memory;\nuse catp2p::error::Error;\n\nfn main() -> Result<(), Error> {\n    let random_score = memory::run_random_access_benchmark()?;\n    println!("Memory Random Access Score: {:.2}", random_score);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"The random access benchmark is important for applications with unpredictable memory access patterns, such as databases or graph processing."}),"\n",(0,s.jsx)(r.h2,{id:"understanding-memory-benchmark-results",children:"Understanding Memory Benchmark Results"}),"\n",(0,s.jsx)(r.p,{children:"The memory benchmark in CatP2P measures several aspects of memory performance:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Allocation Speed"}),": How quickly memory can be allocated and deallocated"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Sequential Access Speed"}),": How quickly data can be read from and written to memory in sequence"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Random Access Speed"}),": How quickly data can be accessed at random locations in memory"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"interpreting-the-score",children:"Interpreting the Score"}),"\n",(0,s.jsx)(r.p,{children:"The overall memory benchmark score is a composite value that represents:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Higher scores indicate better memory performance"}),"\n",(0,s.jsxs)(r.li,{children:["Scores are influenced by:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"RAM speed and latency"}),"\n",(0,s.jsx)(r.li,{children:"Memory controller efficiency"}),"\n",(0,s.jsx)(r.li,{children:"CPU cache size and architecture"}),"\n",(0,s.jsx)(r.li,{children:"Current memory usage and fragmentation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"typical-benchmark-results",children:"Typical Benchmark Results"}),"\n",(0,s.jsx)(r.p,{children:"Memory performance can vary significantly across different systems. Here's an example of benchmark results from an AMD Ryzen 7 3700X system with 16GB of RAM:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"=== CatP2P Memory Information and Benchmarking ===\n\n--- Memory Information ---\nTotal Memory: 15.91 GB\nAvailable Memory: 3.75 GB\nUsed Memory: 12.17 GB\nMemory Usage: 76.45%\nCPU: AMD Ryzen 7 3700X 8-Core Processor (16 cores)\nMemory per CPU core: 0.99 GB\n\n--- Memory Performance Benchmark ---\nMemory Benchmark Score: 19100.72\n\n--- Memory Allocation Performance ---\nAllocation Benchmark Score: 46966.22\n\n--- Memory Read/Write Performance ---\nRead/Write Benchmark Score: 197.93\n\n--- Memory Random Access Performance ---\nRandom Access Benchmark Score: 105.28\n"})}),"\n",(0,s.jsx)(r.p,{children:"This shows that:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Allocation performance is excellent (high score)"}),"\n",(0,s.jsx)(r.li,{children:"Sequential read/write performance is moderate"}),"\n",(0,s.jsx)(r.li,{children:"Random access performance is lower (typical for most systems)"}),"\n",(0,s.jsx)(r.li,{children:"Memory per CPU core is slightly below the recommended 1GB per core"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"factors-affecting-memory-performance",children:"Factors Affecting Memory Performance"}),"\n",(0,s.jsx)(r.p,{children:"Several factors can affect memory benchmark results:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"RAM Configuration"}),": Dual-channel vs. single-channel, number of DIMMs"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"RAM Speed"}),": Higher frequency RAM generally performs better"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"RAM Timings"}),": Lower CAS latency and other timings improve performance"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Memory Controller"}),": The CPU's integrated memory controller affects performance"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"System Load"}),": Other processes using memory can affect benchmark results"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Memory Fragmentation"}),": Long-running systems may have fragmented memory"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Operating System"}),": Memory management differs between operating systems"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"complete-memory-benchmarking-example",children:"Complete Memory Benchmarking Example"}),"\n",(0,s.jsx)(r.p,{children:"Here's a complete example that demonstrates all memory benchmarking capabilities:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use catp2p::benchmark::memory;\nuse catp2p::benchmark::cpu;\nuse catp2p::error::Error;\nuse std::time::Instant;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    println!("=== CatP2P Memory Information and Benchmarking ===\\n");\n    \n    // Get memory information\n    let memory_info = memory::get_memory_info()?;\n    \n    println!("Total Memory: {:.2} GB", bytes_to_gb(memory_info.total_memory));\n    println!("Available Memory: {:.2} GB", bytes_to_gb(memory_info.available_memory));\n    println!("Used Memory: {:.2} GB", bytes_to_gb(memory_info.used_memory));\n    println!("Memory Usage: {:.2}%", memory_info.usage_percent);\n    \n    // Get CPU information for context\n    let cpu_info = cpu::get_cpu_info()?;\n    println!("CPU: {} ({} cores)", cpu_info.name, cpu_info.logical_cores);\n    println!("Memory per CPU core: {:.2} GB", bytes_to_gb(memory_info.memory_per_core));\n    \n    // Run overall memory benchmark\n    println!("\\n--- Memory Performance Benchmark ---");\n    let start_time = Instant::now();\n    let memory_score = memory::run_memory_benchmark()?;\n    let elapsed = start_time.elapsed();\n    println!("Memory Benchmark Score: {:.2}", memory_score);\n    println!("Benchmark completed in {:.2} seconds", elapsed.as_secs_f64());\n    \n    // Run individual memory benchmarks\n    println!("\\n--- Memory Allocation Performance ---");\n    let allocation_score = memory::run_allocation_benchmark()?;\n    println!("Allocation Benchmark Score: {:.2}", allocation_score);\n    \n    println!("\\n--- Memory Read/Write Performance ---");\n    let rw_score = memory::run_read_write_benchmark()?;\n    println!("Read/Write Benchmark Score: {:.2}", rw_score);\n    \n    println!("\\n--- Memory Random Access Performance ---");\n    let random_score = memory::run_random_access_benchmark()?;\n    println!("Random Access Benchmark Score: {:.2}", random_score);\n    \n    // Visualize benchmark results\n    println!("\\n--- Memory Benchmark Visualization ---");\n    println!("Higher is better:");\n    \n    let max_score = [allocation_score, rw_score, random_score, memory_score]\n        .iter()\n        .fold(0.0f64, |a: f64, &b| a.max(b));\n    \n    let scale = 50.0 / max_score;\n    \n    visualize_score("Allocation", allocation_score, scale);\n    visualize_score("Read/Write", rw_score, scale);\n    visualize_score("Random Access", random_score, scale);\n    visualize_score("Overall", memory_score, scale);\n    \n    // Memory performance analysis\n    println!("\\n--- Memory Performance Analysis ---");\n    \n    if allocation_score > 800.0 {\n        println!("\u2705 Memory allocation performance is excellent");\n    } else if allocation_score > 500.0 {\n        println!("\u2713 Memory allocation performance is good");\n    } else {\n        println!("\u26a0 Memory allocation performance is below average");\n    }\n    \n    if rw_score > 800.0 {\n        println!("\u2705 Memory read/write performance is excellent");\n    } else if rw_score > 500.0 {\n        println!("\u2713 Memory read/write performance is good");\n    } else {\n        println!("\u26a0 Memory read/write performance is below average");\n    }\n    \n    if random_score > 800.0 {\n        println!("\u2705 Memory random access performance is excellent");\n    } else if random_score > 500.0 {\n        println!("\u2713 Memory random access performance is good");\n    } else {\n        println!("\u26a0 Memory random access performance is below average");\n    }\n    \n    // Memory recommendations\n    println!("\\n--- Memory Recommendations ---");\n    \n    if memory_info.memory_per_core < 1_073_741_824 { // Less than 1 GB per core\n        println!("\u26a0 Limited memory per CPU core. Consider reducing parallel workloads.");\n    } else if memory_info.memory_per_core > 4_294_967_296 { // More than 4 GB per core\n        println!("\u2705 Excellent memory-to-CPU ratio. Suitable for memory-intensive tasks.");\n    } else {\n        println!("\u2713 Good memory-to-CPU ratio. Suitable for most workloads.");\n    }\n    \n    if memory_info.usage_percent > 80.0 {\n        println!("\u26a0 High memory usage detected. Some benchmarks may be affected.");\n    }\n    \n    Ok(())\n}\n\n// Helper function to convert bytes to gigabytes\nfn bytes_to_gb(bytes: u64) -> f64 {\n    bytes as f64 / 1_073_741_824.0 // 1024^3\n}\n\n// Helper function to visualize a score with a bar chart\nfn visualize_score(name: &str, score: f64, scale: f64) {\n    let bar_length = (score * scale) as usize;\n    let bar = "#".repeat(bar_length);\n    println!("{:14}: {:7.2} |{}|", name, score, bar);\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"best-practices-for-memory-benchmarking",children:"Best Practices for Memory Benchmarking"}),"\n",(0,s.jsx)(r.p,{children:"To get the most accurate results from your memory benchmarks:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Close unnecessary applications"}),": Background processes can consume memory and affect results"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Run benchmarks multiple times"}),": Take the average of several runs to account for variations"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Restart your system before benchmarking"}),": This minimizes memory fragmentation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Be aware of system load"}),": CPU-intensive tasks can affect memory performance"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Consider memory usage"}),": High memory usage can lead to swapping and affect results"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"using-memory-benchmark-results",children:"Using Memory Benchmark Results"}),"\n",(0,s.jsx)(r.p,{children:"The results from memory benchmarking can help you:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Determine if your system is suitable for memory-intensive distributed tasks"}),"\n",(0,s.jsx)(r.li,{children:"Identify potential memory bottlenecks in your application"}),"\n",(0,s.jsx)(r.li,{children:"Compare your node's capabilities with other nodes in the network"}),"\n",(0,s.jsx)(r.li,{children:"Set appropriate memory resource limits in your CatP2P configuration"}),"\n",(0,s.jsx)(r.li,{children:"Make informed decisions about hardware upgrades"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"memory-to-cpu-ratio",children:"Memory-to-CPU Ratio"}),"\n",(0,s.jsxs)(r.p,{children:["The ratio of memory to CPU cores is an important metric for distributed computing. CatP2P calculates this automatically in the ",(0,s.jsx)(r.code,{children:"MemoryInfo"})," struct:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'// Access the memory per core value\nlet memory_info = memory::get_memory_info()?;\nlet mem_per_core = memory_info.memory_per_core;\nprintln!("Memory per CPU core: {:.2} GB", bytes_to_gb(mem_per_core));\n'})}),"\n",(0,s.jsx)(r.p,{children:"General guidelines for memory-to-CPU ratio:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"< 1 GB per core"}),": Limited memory, suitable for lightweight tasks only"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"1-4 GB per core"}),": Good for most workloads"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"> 4 GB per core"}),": Excellent for memory-intensive tasks"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,s.jsx)(r.p,{children:"The CatP2P team is working on improving the memory benchmarking functionality:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Detailed memory latency testing"}),"\n",(0,s.jsx)(r.li,{children:"Memory bandwidth measurements"}),"\n",(0,s.jsx)(r.li,{children:"Cache-aware benchmarks for different cache levels"}),"\n",(0,s.jsx)(r.li,{children:"NUMA (Non-Uniform Memory Access) awareness for multi-socket systems"}),"\n",(0,s.jsx)(r.li,{children:"Memory fragmentation analysis"}),"\n",(0,s.jsx)(r.li,{children:"Integration with the task scheduler to optimize memory usage"}),"\n"]})]})}function d(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>c});var o=n(6540);const s={},i=o.createContext(s);function t(e){const r=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),o.createElement(i.Provider,{value:r},e.children)}}}]);